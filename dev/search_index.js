var documenterSearchIndex = {"docs":
[{"location":"functions/#Module","page":"Functions","title":"Module","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [MAGEMinEnsemble]","category":"page"},{"location":"functions/#MAGEMinEnsemble.MAGEMinEnsemble","page":"Functions","title":"MAGEMinEnsemble.MAGEMinEnsemble","text":"Main module for MAGEMinEnsemble.jl.\n\n\n\n\n\n","category":"module"},{"location":"functions/#FractionalCrystallisation-Submodule","page":"Functions","title":"FractionalCrystallisation Submodule","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [MAGEMinEnsemble.Crystallisation]","category":"page"},{"location":"functions/#MAGEMinEnsemble.Crystallisation.bulk_crystallisation-Tuple{Vector{Float64}, Float64, Vector{Float64}, Any, Vector{String}, String, Union{Nothing, Float64}}","page":"Functions","title":"MAGEMinEnsemble.Crystallisation.bulk_crystallisation","text":"Out = bulk_crystallisation(T_array, P, bulk_init, database, oxides, max_steps, sys_in)\n\nPerform a bulk crystallisation simulation using MAGEMin at constant intensive variables e.g., pressure, oxygen fugacity.\n\nInputs\n\nT_array (Vector{Float64}): Temperatures in degrees Celsius.\nP (Float64): Pressure in kbar.\nbulk_init (Vector{Float64}): Initial bulk composition.\ndatabase: MAGEMin database for simulations. For example, \"ig\" is the igneous database of Holland et al., 2018.\noxides (Vector{String}): Oxides that correspond to values in the bulk composition. See MAGEMin documentation for accepted oxides.\nsys_in (String): Unit for initial bulk composition, can be \"wt\" or \"mol\", for wt(defaults to \"wt\")\n\nOutputs\n\nOut (Vector{MAGEMinC.gminstruct{Float64, Int64}}): array of simulation outputs for each temperature step.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.Crystallisation.fractional_crystallisation-Tuple{Vector{Float64}, Float64, Vector{Float64}, Any, Vector{String}, String, Union{Nothing, Float64}}","page":"Functions","title":"MAGEMinEnsemble.Crystallisation.fractional_crystallisation","text":"Out = fractional_crystallisation(T_array, P, bulk_init, database, oxides, max_steps, sys_in)\n\nPerform a fractional crystallisation simulation using MAGEMin at constant intensive variables e.g., pressure, oxygen fugacity.\n\nInputs\n\nT_array (Vector{Float64}): Temperatures in degrees Celsius.\nP (Float64): Pressure in kbar.\nbulk_init (Vector{Float64}): Initial bulk composition.\ndatabase: MAGEMin database for simulations. For example, \"ig\" is the igneous database of Holland et al., 2018.\noxides (Vector{String}): Oxides that correspond to values in the bulk composition. See MAGEMin documentation for accepted oxides.\nsys_in (String): Unit for initial bulk composition, can be \"wt\" or \"mol\", for wt(defaults to \"wt\")\n\nOutputs\n\nOut (Vector{MAGEMinC.gminstruct{Float64, Int64}}): array of simulation outputs for each temperature step.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MonteCarloBulk-Submodule","page":"Functions","title":"MonteCarloBulk Submodule","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [MAGEMinEnsemble.MonteCarloBulk]","category":"page"},{"location":"functions/#MAGEMinEnsemble.MonteCarloBulk.generate_bulk_mc-Tuple{AbstractDict{String, Float64}, AbstractDict{String, Float64}, Int64}","page":"Functions","title":"MAGEMinEnsemble.MonteCarloBulk.generate_bulk_mc","text":"generate_bulk_mc(bulk, abs_unc, n_samples)\n\nRandomly sample normal distributions for each oxide defined by a bulk composition and its absolute uncertainty, n_samples times.\n\nInputs\n\nbulk (AbstractDict{String, Float64}): Bulk composition with keys as oxide strings, e.g. SiO2.\nabs_unc (AbstractDict{String, Float64}): Absolute uncertainties with keys that correspond to those in bulk.\nn_samples (Int): number of times to sample normal distributions.\n\nOutputs\n\nbulk_mc (AbstractDict{String, Vector{Float64}}): Randomly sampled bulk composition.\n\n\n\n\n\n","category":"method"},{"location":"functions/#InputValidation-Submodule","page":"Functions","title":"InputValidation Submodule","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [MAGEMinEnsemble.InputValidation]","category":"page"},{"location":"functions/#MAGEMinEnsemble.InputValidation.check_buffer_if_offset-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.check_buffer_if_offset","text":"check_buffer_if_offset(constant_inputs::OrderedDict, variable_inputs::OrderedDict)\n\nIf offset is provided, checks that buffer is also provided.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.check_constant_inputs_values-Tuple{OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.check_constant_inputs_values","text":"check_constant_inputs_values(constant_inputs)\n\nCheck the contents of constant_inputs for typing, ensure that numeric values are Float64.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.check_keys_oxygen-Tuple{OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.check_keys_oxygen","text":"oxides = check_keys_oxygen(od)\n\nReturns keys in an ordered dictionary (od) that contain a capital \"O\".\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.check_matching_keys-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.check_matching_keys","text":"check_matching_keys(constant_inputs, variable_inputs)\n\nCheck no keys are defined in both constant and variable inputs.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.check_required_inputs-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.check_required_inputs","text":"check_required_inputs(constant_inputs, variable_inputs)\n\nCheck that list of required inputs is defined in either constantinputs or variableinputs\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.check_variable_inputs_vectors-Tuple{OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.check_variable_inputs_vectors","text":"check_variable_inputs_vectors(variable_inputs)\n\nCheck that variable inputs are Vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.prepare_inputs-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.prepare_inputs","text":"prepare_inputs(constant_inputs, variable_inputs)\n\nPrepare and validate both constantinputs and variableinputs prior to ensure they are suitable for MAGEMin.\n\nInputs:\n\nconstant_inputs (Dict): inputs that will remain unchanged between MAGEMin simulations.\nvariable_inputs (Dict): inputs that vary across MAGEMin simulations.\n\nOutputs:\n\nupdated_constant_inputs (Dict): inputs that will remain unchanged between MAGEMin simulations.\nupdated_variable_inputs (Dict): inputs that vary across MAGEMin simulations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.replace_zero_oxides-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.replace_zero_oxides","text":"new_constant_inputs, new_variable_inputs = replace_zero_oxides!(constant_inputs, variable_inputs)\n\nReplaces oxides, except H2O, defined as 0.0 with 0.001.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.replace_zero_pressure-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.replace_zero_pressure","text":"new_constant_inputs, new_variable_inputs = replace_zero_pressure!(constant_inputs, variable_inputs)\n\nReplaces pressures defined as 0.0 with 0.001\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.validate_buffer-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.validate_buffer","text":"validate_buffer(constant_inputs, variable_inputs)\n\nEnsure that provided buffer string(s) is permitted by MAGEMin.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.validate_oxides-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.validate_oxides","text":"validate_oxides(constant_inputs, variable_inputs)\n\nEnsure that the defined bulk composition has the correct oxides included. Provides error messages that identify missing or extraneous oxides.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.validate_positive_oxides-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.validate_positive_oxides","text":"validate_positive_oxides(constant_inputs, variable_inputs)\n\nEnsures that defined oxide values are positive. Throws an error if they are negative.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.InputValidation.validate_positive_pressure-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.InputValidation.validate_positive_pressure","text":"validate_positive_pressure(constant_inputs, variable_inputs)\n\nEnsures that defined pressure value(s) are positive. Throws an error if they are negative.\n\n\n\n\n\n","category":"method"},{"location":"functions/#GenerateEnsemble-Submodule","page":"Functions","title":"GenerateEnsemble Submodule","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [MAGEMinEnsemble.GenerateEnsemble]","category":"page"},{"location":"functions/#MAGEMinEnsemble.GenerateEnsemble.create_T_array-Tuple{OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.GenerateEnsemble.create_T_array","text":"T_array = create_T_array(all_inputs)\n\nConstruct an array of temperatures from an initial temperature (Tstart), final temperature (Tstop) and temperature increment (Tstep). Ensure that the Tstep is the correct sign.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.GenerateEnsemble.generate_output_filename-Tuple{OrderedCollections.OrderedDict, Tuple{Vararg{Float64}}}","page":"Functions","title":"MAGEMinEnsemble.GenerateEnsemble.generate_output_filename","text":"output_file = generate_output_filename(variable_inputs)\n\nHelper function to generate the output filename. Has different behaviour dependant on the number of oxides in variable_inputs.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.GenerateEnsemble.get_bulk_oxides-Tuple{OrderedCollections.OrderedDict}","page":"Functions","title":"MAGEMinEnsemble.GenerateEnsemble.get_bulk_oxides","text":"bulk_init, Xoxides = get_bulk_oxides(all_inputs)\n\nExtract a bulk composition and matching oxide strings from all_inputs.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MAGEMinEnsemble.GenerateEnsemble.run_simulations","page":"Functions","title":"MAGEMinEnsemble.GenerateEnsemble.run_simulations","text":"results = run_simulations(constant_inputs, variable_inputs, bulk_frac)\n\nGenerates and runs simulation ensembles from intensive variable grid. Extracts inputs from constant and variable_inputs, performs simulations, and saves the outputs to appropriately named .csv and metadata files.\n\nInputs\n\nconstant_inputs (Dict): Intensive variables, excluding T, that remain constant across simulation ensemble.\nvariable_inputs (Dict): Intensive variables, excluding T, that vary across the simulation ensemble.\nbulk_frac (String): Flag to indicate whether bulk or fractional crystallisation simulations should be run. \"bulk\" indicates bulk crystallisation, \"frac\" indicates fractional crystallisation.\n\nKeyword Arguments\n\nsys_in (String): Indicate units for input bulk composition (defaults to \"wt\", wt.%). \"mol\" for mol.%.\noutput_dir (String): Path to save output directory to (defaults to current directory).\ndatabase (String): Thermodynamic database to use (defaults to \"ig\": Green et al., 2025). See the MAGEMin github for options.\n\nOutputs\n\nresults (Dict{String, Any}): simulation results, where keys are variable_input combinations.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MAGEMinEnsemble.GenerateEnsemble.setup_output_directory-Tuple{Union{Nothing, String}}","page":"Functions","title":"MAGEMinEnsemble.GenerateEnsemble.setup_output_directory","text":"output_dir = setup_output_directory(output_dir)\n\nFunction to check whether specified output directory exists. If not, creates directory. If it does, checks for .csv files. If directory contains .csv files throws and error and tells the user to choose another new/empty directory.\n\n\n\n\n\n","category":"method"},{"location":"intensive_variables/#intensive_variables","page":"Intensive Variables","title":"Intensive Variables","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"MAGEMinEnsemble allows the user to define a parameter space over which an ensemble of thermodynamic simulations are performed. This section describes the intensive parameters that can be specified. Mandatory parameters are marked (mandatory). Incorrect inputs will generally result in descriptive errors when the simulations are run.","category":"page"},{"location":"intensive_variables/#Temperature-(mandatory)","page":"Intensive Variables","title":"Temperature (mandatory)","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Temperature is specified using initial (\"T_start\"), final (\"T_stop\") and incremental (\"T_step\") temperatures, in degrees Celsius. Where corresponding values are floats.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"constant_inputs = OrderedDict(\n    \"T_start\" => 1400.,  # Starting temperature (°C)\n    \"T_stop\" => 800.,    # Final temperature (°C)\n    \"T_step\" => -1.      # Temperature step (°C)\n)","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"note: Note\nFor crystallisation simulations, the final temperature may not be reached, as fractional simulations will stop when the bulk solidus (i.e., when the melt fraction is 0). To ensure that the simulations start above the solidus, choose a sufficiently high maximum temperature.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Any or all of the three temperature keys can also be assigned as variable_inputs. For example, running multiple simulations with variable \"T_step\" to investigate the effects of varying temperature increments.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"variable_inputs = OrderedDict(\n    # Different step sizes\n    \"T_step\" => [-1., -2., -5., -10., -20.]\n)","category":"page"},{"location":"intensive_variables/#Bulk-composition-(mandatory)","page":"Intensive Variables","title":"Bulk composition (mandatory)","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"The bulk composition of the simulation is specified in terms of oxide wt.%. MAGEMin operates in an 11-dimensional composition space: Na₂O–CaO–K₂O–FeO–MgO–Al₂O₃–SiO₂–TiO₂–Fe₂O₃–Cr₂O₃–H₂O.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Each oxide is defined by a key, value pair, where the value is a float. All oxide values should be positive. When an oxide is set to 0.0  (except for \"H2O\") it is internally adjusted to 0.001 wt.% to avoid instabilities. See the MAGEMin documentation for more information.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"note: Note\nMAGEMin automatically normalises the assigned composition to 100%.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"For example, a constant bulk composition of KLB-1 basalt can be defined as follows.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"constant_inputs = OrderedDict(\n    # Assign a constant bulk composition in oxide wt.%\n    \"SiO2\"  => 44.66,\n    \"TiO2\"  =>  1.42,\n    \"Al2O3\" => 15.90,\n    \"Cr2O3\" =>  0.00,\n    \"FeO\"   => 11.41,\n    \"Fe2O3\" =>  0.00,\n    \"MgO\"   =>  7.79,\n    \"CaO\"   => 11.24,\n    \"Na2O\"  =>  2.74,\n    \"K2O\"   =>  0.22,\n    \"H2O\"   =>  0.00\n)","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"note: Note\nHere \"Fe2O3\" is given a value of 0.00 i.e. reducing conditions. Oxygen fugacity is discussed in the @ref[Fugacity and Activity] section. Either \"Fe2O3\" or \"O\" must be defined in the bulk composition.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Errors will be thrown if the user defines an oxide outside of MAGEMin's compositional space. Either due to additional oxides, e.g,. \"CuO\" or if any oxides are missing.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Any number of oxides can be defined as vectors in a variable_inputs dictionary:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"variable_inputs = OrderedDict(\n    # Assign a variable H2O content from 0.0 to 8.0 wt.%\n    # in increments of 1.0 wt.%\n    \"H2O\" => collect(range(start=0.0, stop=8.0, step=1.0))\n)","category":"page"},{"location":"intensive_variables/#Pressure-(mandatory)","page":"Intensive Variables","title":"Pressure (mandatory)","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Pressure is defined using the \"P\" key and has units of kilobars (kbar) and must be positive. As with oxides, when a pressure is defined as 0.0 kbar MAGEMinEnsemble automatically converts it to 1 bar to avoid instability. See the MAGEMin documentation for more details.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"# Assign a constant pressure of 1.0 kbar\nconstant_inputs = OrderedDict(\n    \"P\" => 1.0\n)","category":"page"},{"location":"intensive_variables/#Fugacity-and-Activity","page":"Intensive Variables","title":"Fugacity and Activity","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"The fugacity (or activity) for compounds during the simulation can be buffered using the \"buffer\" and \"offset\" keys. The \"buffer\" value must be a string, while \"offset\" values are floats. If \"offset\" is defined, a \"buffer\" must also be defined.","category":"page"},{"location":"intensive_variables/#Buffer","page":"Intensive Variables","title":"Buffer","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"There are several buffers available in MAGEMin. These can be divided into two types, (1) oxygen fugacity buffers, and (2) activity buffers.","category":"page"},{"location":"intensive_variables/#1.-Oxygen-Fugacity-Buffers","page":"Intensive Variables","title":"1. Oxygen Fugacity Buffers","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"The oxygen fugacity buffer constrains the free oxygen content according to a pressure-temperature relationship. The available buffers in MAGEMin are:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Quartz-Fayalite-Magnetite (\"qfm\")\nQuartz-Iron_Faylite (\"qif\")\nNickel-Nickel Oxide (\"nno\")\nHematite-Magnetite (\"hm\")\nIron-Wüstite (\"iw\")\nCarbon Dioxide-Carbon (\"cco\")","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"If an oxygen fugacity buffer is set, there must be sufficient \"O\" or \"Fe2O3\" defined in the bulk composition to saturate the system at that buffer. Excess \"O\" or \"Fe2O3\" will be removed. The oxygen (\"O\") content is set to be equal to \"Fe2O3\". Therefore both \"O\" and \"Fe2O3\" should not be defined in the bulk composition.","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Assigning a constant oxygen fugacity buffer:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"# Assign a constant oxygen fugacity at the QFM buffer\nconstant_inputs = OrderedDict(\n    \"buffer\" => \"qfm\"\n)","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"Running simulations with different buffers:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"# Assign a variable oxygen fugacity at the QFM and NNO buffers\nvariable_inputs = OrderedDict(\n    \"buffer\" => [\"qfm\", \"nno\"]\n)","category":"page"},{"location":"intensive_variables/#2.-Activity-Buffers","page":"Intensive Variables","title":"2. Activity Buffers","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"In the same manner, activity for a given oxide can be fixed using the following activity buffers:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"\"aH2O\" using water as reference phase\n\"aO2\" using dioxygen as reference phase\n\"aMgO\" using periclase as reference phase\n\"aFeO\" using ferropericlase as reference phase\n\"aAl2O3\" using corundum as reference phase\n\"aTiO2\" using rutile as reference phase\n\"aSiO2\" using quartz/coesite as reference phase","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"As with the oxygen fugacity buffers, the corresponding oxide content must be sufficient to saturate the system. Excess oxide-content will be removed at each simulation step.","category":"page"},{"location":"intensive_variables/#Buffer-Offset","page":"Intensive Variables","title":"Buffer Offset","text":"","category":"section"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"To perform the simulation at an activity or oxygen fugacity offset from the buffer the key \"offset\" can be used, where the offset is given in log10 units. A constant buffer and offset of QFM+1 can be set using:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"constant_inputs = OrderedDict(\n    \"buffer\" => \"qfm\",\n    \"offset\" => 1.0,\n)","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"A variable offset can be defined by including the \"offset\" key in the variable_inputs dictionary:","category":"page"},{"location":"intensive_variables/","page":"Intensive Variables","title":"Intensive Variables","text":"constant_inputs = OrderedDict(\n    # \"buffer\" must be defined if \"offset\" is defined\n    \"buffer\" => \"qfm\"\n)\n\nvariable_inputs = OrderedDict(\n    # perform simulations at QFM-2.0 to QFM+2.0 in increments of 1.0 log10 units\n    \"offset\" => [-2.0, -1.0, 0.0, 1.0, 2.0]\n)","category":"page"},{"location":"basic_usage/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Simply put, MAGEMinEnsemble provides an interface to define a parameter space over which many MAGEMin simulations can be performed. It does this using two ordered dictionaries: constant_inputs and variable_inputs. As their names suggest, keys in constant_inputs assign the intensive variables that do not change across the ensemble of simulations. The keys in variable_inputs assign intensive variables that change across the ensemble.","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Intensive variables are assigned using key-value pairs, where the key is always a string. constant_inputs contains values that are single floats or strings. variable_inputs contains values that are vectors of floats or strings. The same key cannot be assigned in both constant_inputs and variable_inputs: a parameter cannot be defined as both constant and variable in the same simulation.","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The below example shows how the key and values of constant_inputs and variable_inputs can be assigned. These will define an ensemble of simulations over variable pressure, water and oxygen fugacity space. For a description of the available intensive variables, see section Intensive Variables.","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Assign a constant temperature range, bulk composition and oxygen fugacity buffer\nconstant_inputs = OrderedDict(\n    # Set the initial, final and incremental\n    # temperature in degrees celsius\n    \"T_start\" => 1400.,\n    \"T_stop\" => 800.,\n    \"T_step\" => -1.,\n\n    # Set bulk composition oxides in wt.% oxide\n    \"SiO2\"  => 44.66,\n    \"TiO2\"  =>  1.42,\n    \"Al2O3\" => 15.90,\n    \"Cr2O3\" =>  0.00,\n    \"FeO\"   => 11.41,\n    \"Fe2O3\" =>  6.00,\n    \"MgO\"   =>  7.79,\n    \"CaO\"   => 11.24,\n    \"Na2O\"  =>  2.74,\n    \"K2O\"   =>  0.22,\n\n    # Set constant oxygen fugacity buffer\n    \"buffer\" => \"qfm\"\n)\n\n# Assign variable pressure, oxygen fugacity buffer offset and water content\nvariable_inputs = OrderedDict(\n    # Set variable pressure between 0.0 and 5.0 kbar in increments of 1.0\n    \"P\" => collect(range(start=0.0, stop=5.0, step=1.0)),\n\n    # Set variable oxygen fugacity buffer offset from\n    # QFM-2.0 to QFM+2.0 in increments of 1.0 log units\n    \"offset\" => [-2.0, -1.0, 0.0, 1.0, 2.0],\n\n    # Set variable water content from 0.0 to 8.0 wt%\n    #in increments of 1.0\n    \"H2O\" => collect(range(start=0.0, stop=8.0, step=1.0))\n)\n\n# Run the simulations, store result in variable Output\nOutput = GenerateEnsemble.run_simulations(\n    constant_inputs,\n    variable_inputs,\n    bulk_frac=\"frac\"\n    )","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The constant_inputs and variable_inputs are passed to the run_simulations() function to generate and run the ensemble. The bulk_frac argument can be either \"bulk\" or \"frac\" to indicate bulk or fractional crystallisation. The results will be saved as appropriately named .csv files. For this ensemble, they will have the form \"P=X_offset=Y_H2O=Z.csv\", where X, Y and Z refer to the combination of values in variable_inputs. The .csv files will be accompanied by metadata.txt files.","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"(Image: Output File Examples)","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"To allow for further processing in Julia, the results are also stored in the variable Output.","category":"page"},{"location":"#MAGEMinEnsemble.jl-Documentation","page":"Home","title":"MAGEMinEnsemble.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MAGEMinEnsemble is a Julia-based software designed to perform an ensemble of fractional crystallisation simulations across a defined intensive variable space. It utilises the Julia wrapper of MAGEMin to perform these simulations. The software is heavily inspired by Zack Gainsforth's alphaMELTSEnsemble, which similarly performs a series of thermodynamic simulations of magmatic systems using alphaMELTS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The key features MAGEMinEnsemble provides are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constant and variable intensive parameters are defined in simple dictionaries.\nAn ensemble of fractional crystallisation simulations is assembled and ran across the defined parameter space.\nAll outputs are saved into appropriately named .csv files.\nSimple Monte Carlo functionality to assess the impact of uncertainties in bulk composition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is a work in progress and additional functionality will be added in the future.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MAGEMinEnsemble is currently unregistered and must be installed using Pkg and directing it to the MAGEMinEnsemble.jl source file. Download this repository. Add the following to the top of your script.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(path=\"Path/To/MAGEMinEnsemble\")\n\nusing MAGEMinEnsemble","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"see Basic Usage for an introduction to using the package;\nthe Intensive Variables explains the different intensive variables.\nSee Functions for a list of all functions and links to their source code.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The goals of this tutorial are as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Provide a brief introduction to MAGEMin, and\nDemonstrate the key functionality of MAGEMinEnsemble and provide simple examples of its usage.","category":"page"},{"location":"tutorial/#Mineral-Assemblage-Gibbs-Energy-Minimization-(MAGEMin)","page":"Tutorial","title":"Mineral Assemblage Gibbs Energy Minimization (MAGEMin)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"MAGEMin is a parallel C library that finds the thermodynamically most stable assemblage for a given bulk rock composition and intensive variables e.g., temperature and pressure. It utilises modern minimisation techniques and optimised for multi-core processors meaning it is both stable and fast.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It utilises existing thermodynamic databases allowing it to perform calculations across a broad compositional and intensive variable space. See the MAGEMin Github and companion paper for further details.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"MAGEMin_C provides a more user-friendly Julia-based interface for performing simulations using MAGEMin, and is utilised by MAGEMinEnsemble for performing many fractional-crystallisation simulations.","category":"page"},{"location":"tutorial/#Single-Calculations","page":"Tutorial","title":"Single Calculations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing single calculations using MAGEMin_C is straightforward with some experience of the programming language Julia. The below snippet shows how to find the stable assemblage for a basaltic composition at 1200texttextdegreeC and 1kbar.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MAGEMin_C\n\ndb = \"ig\"  # database: ig, igneous (Holland et al., 2018)\ndatabase = Initialize_MAGEMin(db, verbose=true);\ndata = use_predefined_bulk_rock(database, 0);  # KLB1\nP = 1.0;  # pressure in kbar\nT = 1200.0;  # temperature in celsius\n\nout  = point_wise_minimization(P, T, database);","category":"page"},{"location":"tutorial/#Multiple-Calculations","page":"Tutorial","title":"Multiple Calculations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Again, setting up and performing multiple calculations is straightforward. The function multi_point_minimization is written to perform simulations in parallel","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MAGEMin_C\n\ndb = \"ig\"  # database: ig, igneous (Holland et al., 2018)\ndatabase = Initialize_MAGEMin(db, verbose=false);\nn_points = 1000\nP = rand(8.0:40, n);  # 1000 pressures between 8 and 40 kbar\nT = rand(800.0:2000.0, n);  # 1000 temperatures between 800 and 2000 celsius\nout  = multi_point_minimization(P, T, database, test=0);  # KLB1\nFinalize_MAGEMin(data)\n","category":"page"},{"location":"tutorial/#Many-(Many)-Calculations","page":"Tutorial","title":"Many (Many) Calculations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing many (1,000s) of simulations across a varied intensive parameter space is less straightforward. Moreover, fractional crystallisation simulations require that the melt at each temperature state is used for subsequent, down-temperature, steps. Therefore each temperature step cannot be performed in parallel. Finally, storing the output of these many simulations allowing them to be subsequently explored is non-trivial.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"MAGEMinEnsemble provides a simple means to define a intensive variable space over which to perform a series of fractional crystallisation experiments. The user defines a temperature array (T_array); constant_inputs, intensive variables that are the same across the defined parameter space; and variable_inputs, those that define the extent of the parameter extent.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MAGEMin_C\nusing OrderedCollections\nusing GenerateEnsemble\n\n# Descending temperature array [celsius]\nT_array = collect(range(start=1400., stop=800., step=-2))\n\nconstant_inputs = Dict()\n# Initial bulk composition [oxide wt%]\nconstant_inputs[\"bulk\"] = OrderedDict(\n    \"SiO2\" => 38.4,\n    \"TiO2\" => 0.7,\n    \"Al2O3\" => 7.7,\n    \"Cr2O3\" => 0.0,\n    \"FeO\" => 5.98,\n    \"MgO\" => 9.95,\n    \"CaO\" => 8.25,\n    \"Na2O\" => 2.26,\n    \"K2O\" => 0.24,\n    \"O\" => 4.0,\n    \"H2O\" => 12.7,\n)\n\nvariable_inputs = Dict()\n# Variable pressure [kbar]\nvariable_inputs[\"P\"] = collect(range(start=0.0, stop=2.0, step=0.5))\n\nsys_in = \"wt\"  # Bulk composition defined in oxide wt%","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The above snippet is the setup to perform five fractional crystallisation simulations. The stable thermodynamic assemblage will be calculated between 1400 and 800 texttextdegreeC in 2 degree temperature steps. Note that the actual lowest temperature in the simulations will be the solidus. A constant initial bulk composition is provided in wt% oxide. Five pressures are defined as a variable input between 0 and 2 kbar in steps of 0.5 kbar.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These fractional crystallisation experiments are then performed as follows.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Output = GenerateEnsemble.run_simulations(T_array, constant_inputs, variable_inputs, sys_in)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Five .csv files (and accompanying metadata.txt files), one for each variable_input combination, will be produced in the current directory containing the most thermodynamically stable phase assemblage at each temperature step. They will have simple names: P=0.0.csv, P=0.5.csv etc.","category":"page"},{"location":"tutorial/#A-More-Complex-Example","page":"Tutorial","title":"A More Complex Example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The above example illustrates how the definition of constant and variable input dictionaries defines the parameter space over which the simulations are performed. Let's add an additional variable_input, oxygen fugacity buffer offset.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MAGEMin_C\nusing OrderedCollections\nusing GenerateEnsemble\n\n# Descending temperature array [celsius]\nT_array = collect(range(start=1400., stop=800., step=-2))\n\nconstant_inputs = Dict()\n# Oxygen fugacity buffer set to Quartz-Fayalite-Magnetite (QFM) buffer\nconstant_inputs[\"buffer\"] = \"qfm\"\n# Initial bulk composition [oxide wt%]\nconstant_inputs[\"bulk\"] = OrderedDict(\n    \"SiO2\" => 38.4,\n    \"TiO2\" => 0.7,\n    \"Al2O3\" => 7.7,\n    \"Cr2O3\" => 0.0,\n    \"FeO\" => 5.98,\n    \"MgO\" => 9.95,\n    \"CaO\" => 8.25,\n    \"Na2O\" => 2.26,\n    \"K2O\" => 0.24,\n    \"O\" => 4.0,\n    \"H2O\" => 12.7,\n)\n\nvariable_inputs = Dict()\n# Variable pressure [kbar]\nvariable_inputs[\"P\"] = collect(range(start=0.0, stop=2.0, step=0.5))\n# Variable buffer offset [log units]\nvariable_inputs[\"buffer_offset\"] = collect(range(start=-2., stop=2., step=1.))\n\nsys_in = \"wt\"  # Bulk composition defined in oxide wt%\n\nOutput = GenerateEnsemble.run_simulations(T_array, constant_inputs, variable_inputs, sys_in)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This time the snippet will run a fractional crystallisation simulation for each pressure-offset pair. There are five pressures (0-2 kbar in 0.5 kbar increments) and five buffer offsets (QFM -2 to +2 in 1 log unit increments), giving a total of 25 simulations. The output of each simulation is again saved as a .csv file. This time they will be called P=0.0bufferoffset=-2.0.csv, P=0.0bufferoffset=-1.0.csv... P=2.0bufferoffset=2.csv, making the intensive variables straightforward to identify.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This shows how by simply defining an additional variable_input parameter a broad range of fractional simulations can be performed.","category":"page"},{"location":"tutorial/#Variable-Bulk-Composition","page":"Tutorial","title":"Variable Bulk Composition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A variable bulk composition can be defined in multiple ways. First a single oxide can be defined as a vector. Here the constant oxides in the bulk composition are defined in the constant_inputs[\"bulk\"] dictionary and the changing oxide is defined in the variable_inputs[\"bulk\"] dictionary.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"constant_inputs = Dict()\nconstant_inputs[\"bulk\"] = OrderedDict(\n    \"SiO2\" => 38.4,\n    \"TiO2\" => 0.7,\n    \"Al2O3\" => 7.7,\n    \"Cr2O3\" => 0.0,\n    \"FeO\" => 5.98,\n    \"MgO\" => 9.95,\n    \"CaO\" => 8.25,\n    \"Na2O\" => 2.26,\n    \"K2O\" => 0.24,\n    \"O\" => 4.0,\n    # \"H2O\" => 12.7,\n)\n\nvariable_inputs = Dict()\nvariable_inputs[\"bulk\"] = OrderedDict(\n    \"H2O\" => collect(range(start=0.0, stop=6.0, step=1.0))\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nMAGEMin automatically normalises the input bulk composition to 100 wt% and that changing an individual oxide by 1 wt.% is a relative change, not an absolute change.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly multiple, but not all, oxides can be defined as vectors. Those in the variable_inputs[\"bulk\"] dictionary must be the same length.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"constant_inputs = Dict()\nconstant_inputs[\"bulk\"] = OrderedDict(\n    \"SiO2\" => 38.4,\n    \"TiO2\" => 0.7,\n    \"Al2O3\" => 7.7,\n    \"Cr2O3\" => 0.0,\n    \"FeO\" => 5.98,\n    \"MgO\" => 9.95,\n    \"CaO\" => 8.25,\n    # \"Na2O\" => 2.26,\n    \"K2O\" => 0.24,\n    \"O\" => 4.0,\n    # \"H2O\" => 12.7,\n)\n\nvariable_inputs = Dict()\nvariable_inputs[\"bulk\"] = OrderedDict(\n    \"H2O\"  => collect(range(start=0.0, stop=6.0, step=1.0)),\n    \"Na2O\" => collect(range(start=0.0, stop=6.0, step=1.0))\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, all oxides can be defined as vectors. In this case all vectors must have the same length.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_steps = 25\nvariable_inputs = Dict()\nvariable_inputs[\"bulk\"] = OrderedDict(\n    \"SiO2\"  => collect(LinRange(30., 50., n_steps)),\n    \"TiO2\"  => collect(LinRange( 0.,  2., n_steps)),\n    \"Al2O3\" => collect(LinRange( 5., 10., n_steps)),\n    \"Cr2O3\" => collect(LinRange( 0.,  2., n_steps)),\n    \"FeO\"   => collect(LinRange( 5., 10., n_steps)),\n    \"MgO\"   => collect(LinRange( 7., 12., n_steps)),\n    \"CaO\"   => collect(LinRange( 7., 12., n_steps)),\n    \"Na2O\"  => collect(LinRange( 2.,  8., n_steps)),\n    \"K2O\"   => collect(LinRange( 0.,  2., n_steps)),\n    \"O\"     => collect(LinRange( 1., 10., n_steps)),\n    \"H2O\"   => collect(LinRange( 0., 10., n_steps))\n)","category":"page"},{"location":"tutorial/#Monte-Carlo-Uncertainty-Propagation-of-Bulk-Compositions","page":"Tutorial","title":"Monte Carlo Uncertainty Propagation of Bulk Compositions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bulk compositions defined in the previous snippet do not represent realistic compositions. A more realistic scenario would be assessing the impact of analytical uncertainty in the bulk composition on the results of fractional crystallisation models. MAGEMinEnsemble has a function specially designed for this. The function generate_bulk_mc accepts two dictionaries, one defining a bulk composition as above, and a second containing corresponding absolute uncertainties. It produces a vector n_samples long for each oxide where each value is randomly sampled from a normal distribution defined by the measured value and its analytical uncertainty.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bulk = OrderedDict(\n    \"SiO2\"  => 44.66,\n    \"TiO2\"  =>  1.42,\n    \"Al2O3\" => 15.90,\n    \"Cr2O3\" =>  0.00,\n    \"FeO\"   => 11.41,\n    \"MgO\"   =>  7.79,\n    \"CaO\"   => 11.24,\n    \"Na2O\"  =>  2.74,\n    \"K2O\"   =>  0.22,\n    \"O\"     =>  4.00,\n    \"H2O\"   =>  0.00\n)\n\nabs_unc = OrderedDict(\n    \"SiO2\"  => 2.333,\n    \"TiO2\"  => 0.142,\n    \"Al2O3\" => 0.795,\n    \"Cr2O3\" => 0.0,\n    \"FeO\"   => 0.571,\n    \"MgO\"   => 0.390,\n    \"CaO\"   => 0.562,\n    \"Na2O\"  => 0.137,\n    \"K2O\"   => 0.022,\n    \"O\"     => 0.0,\n    \"H2O\"   => 0.0\n)\n\nn_samples = 5\n\nbulk_mc = MonteCarloBulk.generate_bulk_mc(bulk, abs_unc, n_samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each oxide in bulk_mc is then a vector containing 5 floats. Those values with an uncertainty of 0.0 are simply copied n_samples times. The function automatically replaces any negative values produced by the sampling by 0.0. The resulting dictionary can be input as a variable_input to assess how the analytical uncertainty impacts the fractional crystallisation simulations.","category":"page"}]
}
